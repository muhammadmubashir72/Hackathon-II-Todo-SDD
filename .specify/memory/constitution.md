<!--
Sync Impact Report:
- Version change: 1.0.0 → 1.1.0
- Modified principles: All principles enhanced with detailed guidance on reusable intelligence and agent architecture
- Added sections: Reusable Intelligence Requirements, Agent & Subagent Architecture, Skills Policy
- Templates requiring updates:
  - ✅ plan-template.md - Technical context already aligns with constitution
  - ✅ spec-template.md - Requirements and user stories align with constitution
  - ✅ tasks-template.md - Task organization and dependencies align with constitution
- Follow-up TODOs: None
-->

# Todo Console App Constitution - Phase I

## Core Principles

### Spec-Driven Development (SDD) Compliance
This project strictly follows Spec-Driven Development (SDD). No code may be generated without an approved specification, implementation plan, testable tasks, and documented implementation steps. Implementation must be generated by Claude Code agents only, following defined workflows.

### Reusable Intelligence Philosophy
Business logic MUST survive UI changes. Validation, formatting, task-state rules, and all core domain logic must remain consistent across interfaces (CLI → API → Chatbot → Cloud). Agents, Subagents, and Skills represent reusable intelligence, not hard-coded behavior. No implementation may bypass reusable skills.

### Single-Responsibility Architecture
Main Agent acts as orchestrator for system-level reasoning. Subagents specialize in distinct responsibilities: validation logic, input parsing behavior, output formatting consistency, task state management, and error handling. Subagents represent separation of responsibilities, not complexity for its own sake.

### Code Quality and Structure
Code MUST be simple, readable, and modular. Functions MUST follow single-responsibility principle. Error messages MUST remain consistent, human-friendly, and avoid technical jargon. Console output MUST be structured and predictable.

## Programming Constraints

### Language and Environment
- Language: Python 3.13+
- Interface: Console (CLI) only
- Storage: In-memory only (no database, no persistence, no files)
- Platform: Linux / WSL compatible
- Dependencies: Python standard library only
- No external frameworks, no databases, no persistence layers

### Quality Rules
- Each task MUST have a unique ID
- Tasks MUST support complete and incomplete states
- Errors MUST be handled gracefully (invalid ID, empty list, malformed input)
- Output MUST be human-readable and consistent in terminal
- All validation, parsing, formatting, and error handling MUST use defined skills

## Reusable Intelligence Requirements

### Task Model Stability
Task model MUST remain stable across phases. Core task attributes (ID, title, state, timestamps) MUST NOT change between CLI, API, and Chatbot implementations to ensure data consistency.

### Validation Rule Consistency
Validation rules MUST be shared and consistent across all phases. task_validation skill encodes all validation logic; no phase-specific validation rules may exist.

### Input Parsing Centralization
Input parsing MUST be centralized and reusable. input_parsing skill handles all raw input normalization and conversion; no duplicate parsing logic allowed in any interface layer.

### Output Formatting Uniformity
Output formatting MUST be consistent. task_formatting skill defines how task data is presented; all interfaces (CLI, API responses, Chat UI) MUST follow the same formatting principles, adapting to presentation layer as needed.

### Task State Management
Task lifecycle rules MUST be centralized. task_state_management skill governs state transitions; no interface may bypass or duplicate state logic.

### Error Handling Consistency
Error experience MUST be consistent across phases. error_handling skill standardizes error generation and display; all phases MUST follow the same tone, structure, and recovery patterns.

## Agent & Subagent Architecture

### Main Agent (Orchestrator)
- Role: System-level reasoning and workflow orchestration
- Responsibilities: Coordinate subagents, manage overall execution flow, ensure compliance with SDD principles
- Behavior: DO NOT improvise or invent features not in spec; DO NOT modify architecture without updating plan; If ambiguity exists, request clarification instead of guessing

### Subagent Responsibilities

**Validation Logic Subagent**
- Specializes in validating all task operations before execution
- Uses task_validation skill for all validation rules
- Ensures data integrity and prevents invalid states

**Input Parsing Subagent**
- Specializes in converting raw user input into clean, usable data
- Uses input_parsing skill for all normalization and conversion
- Prevents application crashes due to malformed input

**Output Formatting Subagent**
- Specializes in presenting task data consistently and clearly
- Uses task_formatting skill for uniform display format
- Ensures output style is consistent across all views

**Task State Management Subagent**
- Specializes in controlling and maintaining task lifecycle
- Uses task_state_management skill for all state transitions
- Ensures valid state changes and prevents invalid transitions

**Error Handling Subagent**
- Specializes in standardizing error generation and display
- Uses error_handling skill for all error messages
- Avoids technical jargon and focuses on clarity and helpfulness

## Skills Policy

### Mandatory Skills (Must Be Reused Across Phases)
- **task_validation**: Validates task operations (title not empty, ID exists, prevent duplicates)
- **input_parsing**: Normalizes and converts user input (menu selections, text trimming, numeric validation)
- **task_formatting**: Formats task display (ID, title, status, list layout)
- **error_handling**: Generates and displays errors (meaningful messages, user-friendly tone)
- **task_state_management**: Manages task lifecycle (state transitions, completion toggling)

### Skills Behavior Requirements
- Skills MUST encode reusable logic rather than UI-specific instructions
- Skills MUST remain portable to future phases (CLI → API → Chatbot → Cloud)
- Skills MUST avoid duplication across modules
- No implementation may bypass required skills
- Skills represent single source of truth for their respective domains

## Non-Goals (Phase I)

### Explicitly Out of Scope
- No persistence or database storage
- No networking or API layer
- No GUI or web interface
- No authentication system
- No cloud integration
- No advanced features (due dates, reminders, priorities, tags, task dependencies)

### Future Phase Considerations
These non-goals are reserved for future phases and MUST NOT be implemented in Phase I. Architecture MUST be designed to support these features without rewriting core logic.

## Project Goals

### Primary Objectives
- Build a clean, modular Todo CLI application
- Maintain reusable task logic across all phases
- Keep business rules separated from interface logic
- Support future evolution (API → Chatbot → Cloud) without rewriting core logic

### Success Criteria
- CLI application functions correctly end-to-end
- Business rules remain reusable and isolated
- Agents + Skills design is clearly traceable in spec
- Output behavior matches acceptance rules
- All five skills are used and no validation/parsing/formatting logic exists outside skills

## Development Workflow

### Spec-Driven Development Process
1. Create or update feature specification (spec.md)
2. Generate implementation plan (plan.md) with architecture decisions
3. Generate testable tasks (tasks.md) aligned with user stories
4. Execute implementation through agents using required skills
5. Validate against success criteria and acceptance rules

### Agent Behavior Rules
- DO NOT improvise or invent features not in spec
- DO NOT modify architecture without updating plan
- If ambiguity exists, request clarification instead of guessing
- No implementation may bypass reusable skills
- All work must be traceable to spec and tasks

## Governance

### Constitution Supremacy
This constitution supersedes all other practices and conventions. All implementations, plans, and specs must align with these principles.

### Amendment Procedure
- Amendments require documentation and version bump
- Versioning follows semantic versioning: MAJOR (incompatible changes), MINOR (new principle/section), PATCH (clarifications)
- Any change affecting reusable intelligence requires updating all relevant skills and templates

### Compliance Review
- All specs must pass constitution checks before planning
- All plans must verify compliance with reusable intelligence requirements
- All implementations must use required skills without bypass

**Version**: 1.1.0 | **Ratified**: 2026-01-02 | **Last Amended**: 2026-01-02
