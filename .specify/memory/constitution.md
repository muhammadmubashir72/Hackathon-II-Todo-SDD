<!--
Sync Impact Report:
- Version change: 2.0.0 → 2.1.0
- Modified principles: Updated for Hackathon II Phase II with strict SDD compliance
- Added sections: Phase II specific constraints and technology stack
- Templates requiring updates: None (reusable templates adapt to new constraints)
- Follow-up TODOs: Ensure all implementations trace back to written specs

Note: This constitution maintains reusable intelligence principles while enforcing strict SDD for Phase II
-->

# Constitution for Phase II - Hackathon II: "The Evolution of Todo – Spec-Driven Development"

## Core Principles

### Spec-Driven Development (SDD) Compliance
This project strictly follows Spec-Driven Development (SDD). No code may be generated without an approved specification, implementation plan, testable tasks, and documented implementation steps. Implementation must be generated by Claude Code agents only, following defined workflows. All changes must pass constitution compliance review before implementation begins.

### Reusable Intelligence Philosophy
Business logic MUST survive UI changes. Validation, formatting, task-state rules, and all core domain logic must remain consistent across interfaces (CLI → API → Web UI → Chatbot → Cloud). Agents, Subagents, and Skills represent reusable intelligence, not hard-coded behavior. No implementation may bypass reusable skills. Core business logic must remain portable across presentation layers (console, web, API, chat).

### Single-Responsibility Architecture
Main Agent acts as orchestrator for system-level reasoning. Subagents specialize in distinct responsibilities: validation logic, input parsing behavior, output formatting consistency, task state management, authentication, and error handling. Subagents represent separation of responsibilities, not complexity for its own sake. Services encapsulate business logic independently from presentation layers (API, Web UI).

### Code Quality and Structure
Code MUST be simple, readable, and modular. Functions MUST follow single-responsibility principle. Error messages MUST remain consistent and appropriate for web consumption (JSON responses with clear error codes). API responses MUST follow REST conventions with appropriate HTTP status codes. Web interface MUST provide intuitive user experience with responsive design patterns. All code MUST include comprehensive type hints and documentation strings for maintainability and scalability across phases.

### Phase I CLI Principles (In-Memory Console Application)
- **Spec-Driven Development is mandatory** - All development must begin with a written specification before any implementation
- **No manual coding outside of /sp.implement** - All code changes must go through the designated implementation workflow
- **Interface**: Console (CLI) with clear, user-friendly prompts and menus
- **Storage**: In-memory only, no persistence requirements
- **Platform**: Linux/WSL compatible with Python standard library only
- **Reusable Intelligence Philosophy**: Business logic MUST survive UI changes; validation, formatting, and task-state rules must remain consistent across interfaces (CLI → API → Web UI → Chatbot → Cloud)
- **All implementations must trace back to written specs** - Every feature and requirement must be linked to the original specification

### Phase II Web Application Principles
- **Spec-Driven Development is mandatory** - All development must begin with a written specification before any implementation
- **No manual coding outside of /sp.implement** - All code changes must go through the designated implementation workflow
- **Clear separation of frontend and backend responsibilities** - Frontend handles presentation logic, backend handles business logic and data persistence
- **Backend is the single source of truth** - All data integrity and business rules are enforced at the backend level
- **Authentication and authorization are mandatory** - Every API endpoint must verify user identity and permissions
- **Strict user data isolation is enforced** - Users can only access their own data unless explicitly granted shared access
- **Reusable Intelligence (agents & skills) must be respected** - Leverage existing agents and skills rather than recreating functionality
- **All implementations must trace back to written specs** - Every feature and requirement must be linked to the original specification


## Programming Constraints

### Language and Environment
- Backend Language: Python 3.13+ with FastAPI framework
- Frontend Language: TypeScript with Next.js framework
- Interface: Web application with responsive UI and REST API endpoints
- Storage: Persistent database using SQLModel with Neon Serverless PostgreSQL
- Platform: Cloud-native compatible (Docker containerizable)
- Dependencies: Standard libraries plus FastAPI, Next.js, SQLModel, Neon, Better Auth

### Phase I CLI Constraints
- **Language**: Python 3.13+
- **Interface**: Console (CLI) with clear, user-friendly prompts
- **Storage**: In-memory only (no persistence)
- **Platform**: Linux/WSL compatible
- **Dependencies**: Python standard library only
- **No database, no networking, no frameworks**

### Phase II Technology Stack
- **Technologies**: Next.js, FastAPI, SQLModel, Neon PostgreSQL
- **Authentication**: JWT-based authentication
- **API Style**: REST APIs only
- **Phase Scope**: Phase II scope only
- **AI Features**: No AI chatbot features (reserved for Phase III)

### Database Architecture
- ORM: SQLModel (combines SQLAlchemy and Pydantic)
- Database: Neon Serverless PostgreSQL (cloud-native, auto-scaling)
- Schema: Normalized with foreign keys ensuring referential integrity
- Migrations: Alembic-managed with version-controlled schema evolution
- Connection: Connection pooling with proper timeout handling
- Security: Parameterized queries to prevent SQL injection

### Authentication & Authorization
- Framework: Better Auth (JWT-based authentication)
- User Isolation: Strict data segregation - users can only access their own tasks
- Session Management: Secure JWT tokens with refresh rotation
- Permissions: Role-based access control (user-specific task access only)
- Security: Password hashing, rate limiting, CSRF protection

### API Design
- Architecture: RESTful endpoints following HTTP standards
- Responses: JSON format with consistent structure
- Status Codes: Standard HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Validation: Request/response validation using Pydantic models
- Error Handling: Structured error responses with error codes and messages
- Pagination: Support for large datasets with pagination parameters

### Quality Rules
- Each task MUST have a unique ID (database-generated primary key)
- Tasks MUST support complete and incomplete states with timestamps
- All endpoints MUST authenticate users and enforce data isolation
- API responses MUST be consistent and well-documented
- All validation, parsing, formatting, authentication, and error handling MUST use defined skills
- Input MUST be sanitized and validated at all entry points
- All database operations MUST use transactions where appropriate

## Reusable Intelligence Requirements

### Task Model Stability
Task model MUST remain stable across phases. Core task attributes (ID, title, state, timestamps, user ownership) MUST NOT change between API, Web UI, and Chatbot implementations to ensure data consistency. Schema evolution MUST maintain backward compatibility for existing clients. New attributes MAY be added but existing ones MUST remain consistent across all interfaces. Foreign key relationships MUST be preserved to maintain referential integrity across phases.


### Validation Rule Consistency
Validation rules MUST be shared and consistent across all phases. task_validation skill encodes all validation logic; no phase-specific validation rules may exist. Web forms, API requests, and database constraints MUST enforce identical validation rules. Client-side and server-side validation MUST align to provide consistent user experience. Authentication and authorization rules MUST be applied consistently across all interfaces. Cross-phase validation skills MUST handle both synchronous and asynchronous contexts appropriately.


### Input Parsing Centralization
Input parsing MUST be centralized and reusable. input_parsing skill handles all raw input normalization and conversion; no duplicate parsing logic allowed in any interface layer. Both API JSON requests and web form submissions MUST use the same parsing logic. Query parameters, request bodies, and form data MUST be normalized through shared skills. Authentication token parsing and validation MUST be centralized. Error reporting from parsing skills MUST be consistent across web and API contexts.


### Output Formatting Uniformity
Output formatting MUST be consistent. task_formatting skill defines how task data is presented; all interfaces (Web UI, API responses, Chat responses) MUST follow the same formatting principles, adapting to presentation layer as needed. API responses MUST use consistent JSON structure. Web UI components MUST present identical data representations as API responses (with UI-appropriate transformations). Error message formatting MUST be consistent across all interfaces. Timestamp formatting and localization MUST be standardized. Success messages and status updates MUST follow consistent patterns across interfaces.


### Task State Management
Task lifecycle rules MUST be centralized. task_state_management skill governs state transitions; no interface may bypass or duplicate state logic. State transitions (pending ↔ completed) MUST follow identical business rules across web and API. Timestamp recording for state changes MUST be consistent. Audit trails for state changes MAY be implemented. State validation MUST prevent invalid transitions in all contexts. Concurrency handling for state changes MUST be addressed in shared logic.


### Authentication & Authorization Centralization
User authentication and authorization logic MUST be centralized. auth_validation skill handles all user identification, permission checking, and data access control. All interfaces MUST verify user identity before allowing data operations. Data isolation rules (users can only access their own tasks) MUST be enforced consistently. Session management MUST be handled through shared authentication skills. Permission escalation prevention MUST be implemented at the skill level. Multi-tenant data isolation MUST be guaranteed across all access methods.


### Error Handling Consistency
Error experience MUST be consistent across phases. error_handling skill standardizes error generation and display; all phases MUST follow the same structure and recovery patterns. API errors MUST use consistent JSON format with error codes. Web interface errors MUST provide user-friendly messages with clear next steps. Authentication errors MUST be handled consistently across all interfaces. Database errors MUST be translated to user-appropriate messages. Logging and monitoring standards MUST be consistent across all error scenarios.


## Agent & Subagent Architecture

### Main Agent (Orchestrator)
- Role: System-level reasoning and workflow orchestration across web and API layers
- Responsibilities: Coordinate subagents, manage overall execution flow, ensure compliance with SDD principles, handle cross-cutting concerns
- Behavior: DO NOT improvise or invent features not in spec; DO NOT modify architecture without updating plan; If ambiguity exists, request clarification instead of guessing; All implementations MUST comply with constitution requirements

### Subagent Responsibilities

**Validation Logic Subagent**
- Specializes in validating all task operations before execution
- Uses task_validation skill for all validation rules (title length, content validity, format compliance)
- Enforces business rules and data integrity constraints
- Handles both request-level and business-level validation

**Input Parsing Subagent**
- Specializes in converting raw user input into clean, usable data
- Uses input_parsing skill for all normalization (JSON parsing, form data extraction, query parameter processing)
- Handles authentication token parsing and validation
- Sanitizes input to prevent injection attacks

**Output Formatting Subagent**
- Specializes in presenting task data consistently and clearly
- Uses task_formatting skill for API JSON responses and web UI data structures
- Ensures consistent data representation across interfaces
- Handles serialization and deserialization of complex objects

**Task State Management Subagent**
- Specializes in controlling and maintaining task lifecycle
- Uses task_state_management skill for all state transitions and timestamp management
- Ensures valid state changes and prevents invalid transitions
- Maintains audit trail of state changes where applicable

**Authentication Subagent**
- Specializes in user identification and permission enforcement
- Uses auth_validation skill for all authentication and authorization operations
- Enforces user isolation and data access controls
- Manages session state and token validation

**Error Handling Subagent**
- Specializes in standardizing error generation and display
- Uses error_handling skill for all error messages and exception responses
- Provides appropriate HTTP status codes and error structures
- Ensures error messages are secure and don't leak sensitive information

## Skills Policy

### Mandatory Skills (Must Be Reused Across Phases)
- **task_validation**: Validates task operations (title not empty, ID exists, prevent duplicates, user ownership)
- **input_parsing**: Normalizes and converts user input (form data, JSON, query params, auth tokens)
- **task_formatting**: Formats task display (JSON responses, web data structures, API serialization)
- **error_handling**: Generates and displays errors (HTTP status codes, JSON error responses, user messages)
- **task_state_management**: Manages task lifecycle (state transitions, completion toggling, timestamp updates)
- **auth_validation**: Handles authentication and authorization (user identification, permission checking, data isolation)

### Skills Behavior Requirements
- Skills MUST encode reusable logic rather than UI-specific instructions
- Skills MUST remain portable to future phases (Web → API → Chatbot → Cloud)
- Skills MUST avoid duplication across modules
- No implementation may bypass required skills
- Skills represent single source of truth for their respective domains
- Skills MUST handle both synchronous and asynchronous contexts where applicable
- Skills MUST be designed for testability and maintainability across phases

## Non-Goals (Phase II)

### Explicitly Out of Scope
- No advanced AI features (natural language processing, smart categorization)
- No real-time synchronization (WebSocket connections, live updates)
- No mobile app development (native iOS/Android apps)
- No advanced analytics or reporting features
- No complex task relationships (dependencies, hierarchies, projects)
- No email notifications or reminder systems
- No file attachments or rich media handling

### Future Phase Considerations
These non-goals are reserved for future phases and MUST NOT be implemented in Phase II. Architecture MUST be designed to support these features without rewriting core logic. Advanced features SHOULD be planned with extension points in mind. Database schema and API design SHOULD accommodate future expansion without breaking changes.


## Project Goals

### Primary Objectives
- Build a secure, scalable Todo web application with user authentication
- Maintain reusable task logic across all phases with improved data persistence
- Implement proper user isolation with authentication and authorization
- Support future evolution (Chatbot → Cloud) without rewriting core logic
- Demonstrate cloud-native deployment readiness with containerization

### Success Criteria
- Web application functions correctly with authenticated users
- Users can only access their own tasks (strict data isolation)
- API endpoints follow REST conventions with proper HTTP status codes
- Database operations are efficient and secure
- Authentication system is robust and secure
- All six skills are used appropriately without validation/parsing/formatting logic outside skills
- Application is containerizable and cloud-ready

## Development Workflow

### Spec-Driven Development Process
1. Create or update feature specification (spec.md) with web-specific requirements
2. Generate implementation plan (plan.md) with architecture decisions including database schema and API design
3. Generate testable tasks (tasks.md) aligned with user stories and web interface requirements
4. Execute implementation through agents using required skills with web-specific adaptations
5. Validate against success criteria and acceptance rules including security and performance

### Agent Behavior Rules
- DO NOT improvise or invent features not in spec
- DO NOT modify architecture without updating plan
- If ambiguity exists, request clarification instead of guessing
- No implementation may bypass reusable skills
- All work must be traceable to spec and tasks
- All database changes must include migration plans
- All API changes must include documentation and versioning considerations

## Governance

### Constitution Supremacy
This constitution supersedes all other practices and conventions. All implementations, plans, and specs must align with these principles. Any deviation requires formal constitution amendment with justification and approval process. All architectural decisions must reference relevant constitution clauses for compliance verification.


### Amendment Procedure
- Amendments require documentation and version bump with clear justification
- Versioning follows semantic versioning: MAJOR (incompatible changes), MINOR (new principle/section), PATCH (clarifications)
- Any change affecting reusable intelligence requires updating all relevant skills and templates
- Amendments must include impact analysis for existing implementations
- Backward compatibility must be maintained wherever possible

### Compliance Review
- All specs must pass constitution checks before planning including security and database requirements
- All plans must verify compliance with reusable intelligence requirements and web-specific constraints
- All implementations must use required skills without bypass and meet web application standards
- Regular compliance audits must be conducted during development to ensure ongoing adherence

**Version**: 2.1.0 | **Ratified**: 2026-01-27 | **Last Amended**: 2026-01-27

## Phase II Applicability

This constitution applies to all agents, skills, plans, and code generated in Phase II of Hackathon II: "The Evolution of Todo – Spec-Driven Development".
